==========================
http://localhost:4000/users/log-out
==========================

# #### Phoenix.Router.NoRouteError at GET /users/log-out

`   no route found for GET /users/log-out (RepRivalsWeb.Router)   `

# ## Available routes

  GET     /                                     RepRivalsWeb.HomeLive :index
  GET     /notebook                             RepRivalsWeb.WorkoutNotebookLive :index
  GET     /workouts/new                         RepRivalsWeb.WorkoutNewLive :new
  GET     /workouts/:id                         RepRivalsWeb.WorkoutDetailLive :show
  GET     /workouts/:id/edit                    RepRivalsWeb.WorkoutEditLive :edit
  GET     /friends                              RepRivalsWeb.FriendsLive :index
  GET     /challenges                           RepRivalsWeb.ChallengesLive :index
  GET     /leaderboard                          RepRivalsWeb.LeaderboardLive :index
  GET     /users/settings                       RepRivalsWeb.UserLive.Settings :edit
  GET     /users/settings/confirm-email/:token  RepRivalsWeb.UserLive.Settings :confirm\_email
  POST    /users/update-password                RepRivalsWeb.UserSessionController :update\_password
  GET     /users/register                       RepRivalsWeb.UserLive.Registration :new
  GET     /users/log-in                         RepRivalsWeb.UserLive.Login :new
  GET     /users/log-in/:token                  RepRivalsWeb.UserLive.Confirmation :new
  POST    /users/log-in                         RepRivalsWeb.UserSessionController :create
  DELETE  /users/log-out                        RepRivalsWeb.UserSessionController :delete
  GET     /dev/dashboard/css-:md5               Phoenix.LiveDashboard.Assets :css
  GET     /dev/dashboard/js-:md5                Phoenix.LiveDashboard.Assets :js
  GET     /dev/dashboard                        Phoenix.LiveDashboard.PageLive :home
  GET     /dev/dashboard/:page                  Phoenix.LiveDashboard.PageLive :page
  GET     /dev/dashboard/:node/:page            Phoenix.LiveDashboard.PageLive :page
  \*       /dev/mailbox                          Plug.Swoosh.MailboxPreview \[\]

\# Phoenix.Router.NoRouteError at GET /users/log-out Exception: \*\* (Phoenix.Router.NoRouteError) no route found for GET /users/log-out (RepRivalsWeb.Router) (rep\_rivals 0.1.0) deps/phoenix/lib/phoenix/router.ex:465: RepRivalsWeb.Router.call/2 (rep\_rivals 0.1.0) lib/rep\_rivals\_web/endpoint.ex:1: RepRivalsWeb.Endpoint.plug\_builder\_call/2 (rep\_rivals 0.1.0) deps/plug/lib/plug/debugger.ex:155: RepRivalsWeb.Endpoint."call (overridable 3)"/2 (rep\_rivals 0.1.0) lib/rep\_rivals\_web/endpoint.ex:1: RepRivalsWeb.Endpoint.call/2 (phoenix 1.8.0) lib/phoenix/endpoint/sync\_code\_reload\_plug.ex:22: Phoenix.Endpoint.SyncCodeReloadPlug.do\_call/4 (bandit 1.7.0) lib/bandit/pipeline.ex:131: Bandit.Pipeline.call\_plug!/2 (bandit 1.7.0) lib/bandit/pipeline.ex:42: Bandit.Pipeline.run/5 (bandit 1.7.0) lib/bandit/http1/handler.ex:13: Bandit.HTTP1.Handler.handle\_data/3 (bandit 1.7.0) lib/bandit/delegating\_handler.ex:18: Bandit.DelegatingHandler.handle\_data/3 (bandit 1.7.0) lib/bandit/delegating\_handler.ex:8: Bandit.DelegatingHandler.handle\_continue/2 (stdlib 6.2.2) gen\_server.erl:2335: :gen\_server.try\_handle\_continue/3 (stdlib 6.2.2) gen\_server.erl:2244: :gen\_server.loop/7 (stdlib 6.2.2) proc\_lib.erl:329: :proc\_lib.init\_p\_do\_apply/3 ## Connection details ### Params %{} ### Request info \* URI: http://localhost:4000/users/log-out \* Query string: ### Session nil

deps/phoenix/lib/phoenix/router.ex

460        case \_\_match\_route\_\_(decoded, method, host) do
461          {metadata, prepare, pipeline, plug\_opts} ->
462            Phoenix.Router.\_\_call\_\_(conn, metadata, prepare, pipeline, plug\_opts)
463
464          :error ->
465            raise NoRouteError, conn: conn, router: \_\_MODULE\_\_
466        end
467      end
468
469      defoverridable init: 1, call: 2
470    end

RepRivalsWeb.Router.call/2 [Docs](https://hexdocs.pm/rep_rivals/0.1.0/RepRivalsWeb.Router.html#call/2) rep\_rivals

lib/rep\_rivals\_web/endpoint.ex

1defmodule RepRivalsWeb.Endpoint do
2  use Phoenix.Endpoint, otp\_app: :rep\_rivals
3
4  # The session will be stored in the cookie and signed,
5  # this means its contents can be read but not tampered with.
6  # Set :encryption\_salt if you would also like to encrypt it.

RepRivalsWeb.Endpoint.plug\_builder\_call/2 rep\_rivals

deps/plug/lib/plug/debugger.ex

150          case conn do
151            %Plug.Conn{path\_info: \["\_\_plug\_\_", "debugger", "action"\], method: "POST"} ->
152              Plug.Debugger.run\_action(conn)
153
154            %Plug.Conn{} ->
155              super(conn, opts)
156          end
157        rescue
158          e in Plug.Conn.WrapperError ->
159            %{conn: conn, kind: kind, reason: reason, stack: stack} = e
160            Plug.Debugger.\_\_catch\_\_(conn, kind, reason, stack, @plug\_debugger)

RepRivalsWeb.Endpoint."call (overridable 3)"/2 rep\_rivals

lib/rep\_rivals\_web/endpoint.ex

1defmodule RepRivalsWeb.Endpoint do
2  use Phoenix.Endpoint, otp\_app: :rep\_rivals
3
4  # The session will be stored in the cookie and signed,
5  # this means its contents can be read but not tampered with.
6  # Set :encryption\_salt if you would also like to encrypt it.

RepRivalsWeb.Endpoint.call/2 rep\_rivals

lib/phoenix/endpoint/sync\_code\_reload\_plug.ex

17
18  def call(conn, {endpoint, opts}), do: do\_call(conn, endpoint, opts, true)
19
20  defp do\_call(conn, endpoint, opts, retry?) do
21    try do
22      endpoint.call(conn, opts)
23    rescue
24      exception in \[UndefinedFunctionError\] ->
25        case exception do
26          %UndefinedFunctionError{module: ^endpoint} when retry? ->
27            # Sync with the code reloader and retry once

Phoenix.Endpoint.SyncCodeReloadPlug.do\_call/4 phoenix

lib/bandit/pipeline.ex

126    end
127  end
128
129  @spec call\_plug!(Plug.Conn.t(), plug\_def()) :: Plug.Conn.t() | no\_return()
130  defp call\_plug!(%Plug.Conn{} = conn, {plug, plug\_opts}) when is\_atom(plug) do
131    case plug.call(conn, plug\_opts) do
132      %Plug.Conn{} = conn -> conn
133      other -> raise("Expected #{plug}.call/2 to return %Plug.Conn{} but got: #{inspect(other)}")
134    end
135  end
136

Bandit.Pipeline.call\_plug!/2 bandit

lib/bandit/pipeline.ex

37      conn = build\_conn!(transport, method, request\_target, headers, conn\_data, opts)
38      span = Bandit.Telemetry.start\_span(:request, measurements, Map.put(metadata, :conn, conn))
39
40      try do
41        conn
42        |> call\_plug!(plug)
43        |> maybe\_upgrade!()
44        |> case do
45          {:no\_upgrade, conn} ->
46            %Plug.Conn{adapter: {\_mod, adapter}} = conn = commit\_response!(conn)
47            Bandit.Telemetry.stop\_span(span, adapter.metrics, %{conn: conn})

Bandit.Pipeline.run/5 bandit

lib/bandit/http1/handler.ex

8  def handle\_data(data, socket, state) do
9    transport = %Bandit.HTTP1.Socket{socket: socket, buffer: data, opts: state.opts}
10    connection\_span = ThousandIsland.Socket.telemetry\_span(socket)
11    conn\_data = Bandit.SocketHelpers.conn\_data(socket)
12
13    case Bandit.Pipeline.run(transport, state.plug, connection\_span, conn\_data, state.opts) do
14      {:ok, transport} -> maybe\_keepalive(transport, state)
15      {:error, \_reason} -> {:close, state}
16      {:upgrade, \_transport, :websocket, opts} -> do\_websocket\_upgrade(opts, state)
17    end
18  end

Bandit.HTTP1.Handler.handle\_data/3 bandit

lib/bandit/delegating\_handler.ex

13    |> handle\_bandit\_continuation(socket)
14  end
15
16  @impl ThousandIsland.Handler
17  def handle\_data(data, socket, %{handler\_module: handler\_module} = state) do
18    handler\_module.handle\_data(data, socket, state)
19    |> handle\_bandit\_continuation(socket)
20  end
21
22  @impl ThousandIsland.Handler
23  def handle\_shutdown(socket, %{handler\_module: handler\_module} = state) do

Bandit.DelegatingHandler.handle\_data/3 bandit

lib/bandit/delegating\_handler.ex

3  # Delegates all implementation of the ThousandIsland.Handler behaviour
4  # to an implementation specified in state. Allows for clean separation
5  # between protocol implementations & friction free protocol selection &
6  # upgrades.
7
8  use ThousandIsland.Handler
9
10  @impl ThousandIsland.Handler
11  def handle\_connection(socket, %{handler\_module: handler\_module} = state) do
12    handler\_module.handle\_connection(socket, state)
13    |> handle\_bandit\_continuation(socket)

Bandit.DelegatingHandler.handle\_continue/2 bandit

gen\_server.erl

No code available.

:gen\_server.try\_handle\_continue/3 stdlib

gen\_server.erl

No code available.

:gen\_server.loop/7 stdlib

proc\_lib.erl

No code available.

:proc\_lib.init\_p\_do\_apply/3 stdlib

Show only app frames Copy markdown

- rep\_rivals deps/phoenix/lib/phoenix/router.ex:465 RepRivalsWeb.Router.call/2
- rep\_rivals lib/rep\_rivals\_web/endpoint.ex:1 RepRivalsWeb.Endpoint.plug\_builder\_call/2
- rep\_rivals deps/plug/lib/plug/debugger.ex:155 RepRivalsWeb.Endpoint."call (overridable 3)"/2
- rep\_rivals lib/rep\_rivals\_web/endpoint.ex:1 RepRivalsWeb.Endpoint.call/2
- phoenix lib/phoenix/endpoint/sync\_code\_reload\_plug.ex:22 Phoenix.Endpoint.SyncCodeReloadPlug.do\_call/4
- bandit lib/bandit/pipeline.ex:131 Bandit.Pipeline.call\_plug!/2
- bandit lib/bandit/pipeline.ex:42 Bandit.Pipeline.run/5
- bandit lib/bandit/http1/handler.ex:13 Bandit.HTTP1.Handler.handle\_data/3
- bandit lib/bandit/delegating\_handler.ex:18 Bandit.DelegatingHandler.handle\_data/3
- bandit lib/bandit/delegating\_handler.ex:8 Bandit.DelegatingHandler.handle\_continue/2
- stdlib gen\_server.erl:2335 :gen\_server.try\_handle\_continue/3
- stdlib gen\_server.erl:2244 :gen\_server.loop/7
- stdlib proc\_lib.erl:329 :proc\_lib.init\_p\_do\_apply/3

Request info

URI:

http://localhost:4000/users/log-out

Query string:

Headers

accept

text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,\*/\*;q=0.8,application/signed-exchange;v=b3;q=0.7

accept-encoding

gzip, deflate, br, zstd

accept-language

en-US,en;q=0.9

connection

keep-alive

cookie

\_rep\_rivals\_key=SFMyNTY.g3QAAAADbQAAAAtfY3NyZl90b2tlbm0AAAAYdGg2dmFOeWtlVGl5YWNuNEVrc3NpbE10bQAAAA5saXZlX3NvY2tldF9pZG0AAAA7dXNlcnNfc2Vzc2lvbnM6R2lOWFk3M1hlX1JoOVlLSTIza29UZWhMNnlZTEF1a0hKRk5TRVpUMDZBQT1tAAAACnVzZXJfdG9rZW5tAAAAIBojV2O913v0YfWCiNt5KE3oS-smCwLpByRTUhGU9OgA.u5TagDx3SiqypO30gKtPhjCqGA9aub8tfshLNRKvbzo

host

localhost:4000

sec-ch-ua

"Chromium";v="133", "Not(A:Brand";v="99"

sec-ch-ua-mobile

?0

sec-ch-ua-platform

"Linux"

sec-fetch-dest

document

sec-fetch-mode

navigate

sec-fetch-site

none

sec-fetch-user

?1

upgrade-insecure-requests

1

user-agent

Mozilla/5.0 (X11; Linux x86\_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/133.0.0.0 Safari/537.36